<h1 id="contract-const-data-sections">Contract const DATA Sections</h1>

<table>
  <thead>
    <tr>
      <th style="text-align: left">RSKIP</th>
      <th style="text-align: left">34</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Title</strong></td>
      <td style="text-align: left">Contract const DATA Sections</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Created</strong></td>
      <td style="text-align: left">20-JAN-2017</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Author</strong></td>
      <td style="text-align: left">SDL</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Purpose</strong></td>
      <td style="text-align: left">Sca</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Layer</strong></td>
      <td style="text-align: left">Core</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Complexity</strong></td>
      <td style="text-align: left">1</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Status</strong></td>
      <td style="text-align: left">Draft</td>
    </tr>
  </tbody>
</table>

<h1 id="abstract"><strong>Abstract</strong></h1>

<p>Contracts can be used as data chuncks because CODECOPY allows copying other contracts code. However code passes semantic checks, and RSK adds headers to code. Therefore code is not suitable anymore to hold unformatted data. This RSKIP discusses how to allow const data sections.</p>

<h2 id="discussion">Discussion</h2>

<p>There are several possible solutions:</p>

<ol>
  <li>
    <p>The code header will allow the specification of two sections. Only two sections will be allowed: code and data. Each section will specify an base offset. Data will be memory-mapped, so that memory gaps do not consume gas‚Äù</p>
  </li>
  <li>
    <p>A new opcode is created: DATA which automatically stops any code analysis. No JUMP will be allowed past this limit. The VM will stop processing if the PC enters the data section as if it was the end of code. The contract that uses CODECOPY must known the offset where data is located.</p>
  </li>
  <li>
    <p>Another approach is that two STOP opcodes in sequence means DATA section starts. The second STOP opcode can not serve any useful use, because there is no JUMPDESTS between them</p>
  </li>
</ol>

<p>Solution 3 is simpler but may break compatibility with Ethereum contracts.</p>

<h1 id="specification"><strong>Specification</strong></h1>

<p>New opcode: DATA</p>

<p>This opcode executes as STOP.</p>

<h1 id="copyright"><strong>Copyright</strong></h1>

<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
