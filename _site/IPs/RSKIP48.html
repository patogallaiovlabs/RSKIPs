<h1 id="informing-average-free-gas-per-block">Informing average free gas per block</h1>

<table>
  <thead>
    <tr>
      <th style="text-align: left">RSKIP</th>
      <th style="text-align: left">48</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Title</strong></td>
      <td style="text-align: left">Informing average free gas per block</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Created</strong></td>
      <td style="text-align: left">28-NOV-2017</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Author</strong></td>
      <td style="text-align: left">SDL</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Purpose</strong></td>
      <td style="text-align: left">Sca</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Layer</strong></td>
      <td style="text-align: left">Core</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Complexity</strong></td>
      <td style="text-align: left">2</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Status</strong></td>
      <td style="text-align: left">Draft</td>
    </tr>
  </tbody>
</table>

<h1 id="abstract"><strong>Abstract</strong></h1>

<p>This document describes a new method provided by the REMASC contract to inform users of the gas availability in the last block intervals. To optimize queries, the REMASC will maintain the average free gas per block at powers of 2, until 8192.</p>

<h1 id="discussion"><strong>Discussion</strong></h1>

<p>Pseudocode for each new block B.</p>

<ol>
  <li>
    <p>prev = B.gasLimit-B.gasUsed</p>
  </li>
  <li>
    <p>w = 0</p>
  </li>
  <li>
    <p>while (w&lt;=13)</p>

    <ol>
      <li>
        <p>b0[w] = b1[w]</p>
      </li>
      <li>
        <p>b1[w] = prev</p>
      </li>
      <li>
        <p>prev = (b0[w] + b1[w]) /2</p>
      </li>
      <li>
        <p>valueAtLevel[w] = prev</p>
      </li>
      <li>
        <p>if (blockNumber &amp; (1«w) ==0) break</p>
      </li>
      <li>
        <p>w++</p>
      </li>
    </ol>
  </li>
</ol>

<p>This is a multi-level averaging filter. The properties of this filter MUST be carefully studied. Each value feeded into a filter of level N is an average of level (N-1) therefore the values come pre-smoothed. The only drawback is that the system updates the filter at level N once every 2^N blocks, which means that the data is always delayed.</p>

<p>For a level of 8192 (approximately one update every day), the value is delayed on average half a day.</p>

<p>One thing one can do is to combine values at different levels at different times, when the blocknumber is not an exact multiple of 2^N.</p>

<p>Eg</p>

<p>Average at blocknumber 8192+100 is</p>

<p>( Block[8192+100].valueAtLevel[log2(8192)] +</p>

<p>Block[8192].valueAtLevel[log2(64)]+</p>

<p>Block[8192+64].valueAtLevel[log2(32)]+</p>

<p>Block[8192+96].valueAtLevel[log2(4)] ) / 4</p>

<p>This computation gives more weight to the last samples. To get a better weight, this is suggested:</p>

<p>( Block[8192+100].valueAtLevel[log2(8192)] *8192+</p>

<p>Block[8192].valueAtLevel[log2(64)] * 64+</p>

<p>Block[8192+64].valueAtLevel[log2(32)] *32+</p>

<p>Block[8192+96].valueAtLevel[log2(4)] * 4) / (8192+64+32+4)</p>

<p>This gives an estimation of the last(8192+64+32+4) blocks.</p>

<p>To obtain an estimation of an exact number of blocks, the bit decomposition of the blocknumber is required.</p>

<p>E.g. At point 8292:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(4 block average at blocknum 104  ) *4 +
</code></pre></div></div>

<p>(8 block average at blocknum 112 ) * 8 +</p>

<p>(16 block average at blocknum 128 )* 16+</p>

<p>(128 block average at blocknum 256) * 128+</p>

<p>(256 block average at blocknum 512)*256+</p>

<p>(512 block average at blocknum 1024)*512+</p>

<p>(1024 block average at blocknum 2048)*1024+</p>

<p>(2048 block average at blocknum 4096)*2048+</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(4096 block average at blocknum 8192 )*4096+

 ( 64 block average at blocknum (8192+64) ) *64+

 ( 32 block average at blocknum (8192+96) ) *32+

 ( 4 block average at blocknum (8192+96+4) )* 4
</code></pre></div></div>

<p>(4+8+16+128+256+512+1024+2048+4096+64+32+4)=8192</p>

<p>Addition way is:</p>

<ul>
  <li>
    <p>Let H be the high limit</p>
  </li>
  <li>
    <p>Let L be the low limit</p>
  </li>
  <li>
    <p>Let a = trunc(log2(H-L))</p>
  </li>
  <li>
    <p>Let p = 2^a</p>
  </li>
  <li>
    <p>Let Ldif = (a-L)</p>
  </li>
  <li>
    <p>Let Ldec = accum_averages(L..a)
bit decomposition and accumulation of averages of Ldif in the range L..a</p>
  </li>
  <li>
    <p>Let Hdif = (H-2*a)</p>
  </li>
  <li>
    <p>Let Hdec = accum_averages(a..H)
bit decomposition and accumulation of averages of Hdif in the range a..H</p>
  </li>
  <li>
    <p>Total = a<em>accum_averages(a..2</em>a)+ Hdec<em>Hdif + Ldec</em>Ldif</p>
  </li>
</ul>

<p>Subtraction way is:</p>

<ul>
  <li>
    <p>Let H be the high limit</p>
  </li>
  <li>
    <p>Let L be the low limit</p>
  </li>
  <li>
    <p>Let a = ceil(log2(H-L))</p>
  </li>
  <li>
    <p>Let p = 2^a</p>
  </li>
  <li>
    <p>Let Ldif = (L-a)</p>
  </li>
  <li>
    <p>Let Ldec = accum_averages(a..L)</p>
  </li>
  <li>
    <p>Let Hdif = (H-2*a)</p>
  </li>
  <li>
    <p>Let Hdec = accum_averages(L..H)</p>
  </li>
  <li>
    <p>Total = a<em>accum_averages(2</em>a)+ Hdec<em>Hdif - Ldec</em>Ldif</p>
  </li>
</ul>

<p>The idea is that one can compute the averages from the lower limit to a higher power of two or to a lower power of two. If it’s higher, we add. If it’s lower we subtract.</p>

<p>The advantage of adding is that it uses a largest power (a) smaller than when subtracting. But the actual addition cost depends on the bit decompositions: if (L-a) has low hamming distance, then addition is better. If (a-L) has low hamming distance, then subtraction is better.</p>

<h1 id="specification"><strong>Specification</strong></h1>

<h2 id="references">References:</h2>

<p><a href="https://github.com/raiden-network/raiden/issues/383">https://github.com/raiden-network/raiden/issues/383</a></p>

<h1 id="copyright"><strong>Copyright</strong></h1>

<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
