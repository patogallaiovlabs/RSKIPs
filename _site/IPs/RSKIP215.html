<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Ephemeral Blockchain | RSK Improvement Proposals</title>
    <meta
      property="og:title"
      content="Ephemeral Blockchain | RSK Improvement Proposals"
    />
    <meta name="description" content="RSK Improvement Proposals (RSKIPs) describe standards for the RSK platform, including core protocol specifications, client APIs, and contract standards." />
    <meta property="og:description" content="RSK Improvement Proposals (RSKIPs) describe standards for the RSK platform, including core protocol specifications, client APIs, and contract standards." />
    <meta name="twitter:description" content="RSK Improvement Proposals (RSKIPs) describe standards for the RSK platform, including core protocol specifications, client APIs, and contract standards." />

  <meta name="generator" content="Jekyll" />
  <meta property="og:locale" content="en_US" />
  <link rel="canonical" href="https://ips.rsk.co/IPs/RSKIP215" />
  <meta property="og:url" content="https://ips.rsk.co/IPs/RSKIP215" />
  <meta property="og:site_name" content="RSK Improvement Proposals" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "https://ips.rsk.co",
      "name": "RSK Improvement Proposals",
      "description": "RSK Improvement Proposals (RSKIPs) describe standards for the RSK platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
  <link rel="stylesheet" href="/assets/css/style.css" />
      <!-- Google Fonts -->
      <link href="https://fonts.googleapis.com/css?family=Quicksand:400,700,900&display=swap" rel="stylesheet">
      <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,600,700,800&display=swap" rel="stylesheet"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="RSK Improvement Proposals" /><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha256-nlrDrBTHxJJlDDX22AS33xYI1OJHnGMDhiYMSe2U0e0=" crossorigin="anonymous"></script>
</head>
<body><header class="site-header" role="banner">
  <button id="dark-mode-toggle" class="dark-mode-toggle theme-toggle-button">
    <svg class="icon" style="width:24px;height:24px" viewBox="0 0 24 24">
      <path fill="currentColor" d="M7.5,2C5.71,3.15 4.5,5.18 4.5,7.5C4.5,9.82 5.71,11.85 7.53,13C4.46,13 2,10.54 2,7.5A5.5,5.5 0 0,1 7.5,2M19.07,3.5L20.5,4.93L4.93,20.5L3.5,19.07L19.07,3.5M12.89,5.93L11.41,5L9.97,6L10.39,4.3L9,3.24L10.75,3.12L11.33,1.47L12,3.1L13.73,3.13L12.38,4.26L12.89,5.93M9.59,9.54L8.43,8.81L7.31,9.59L7.65,8.27L6.56,7.44L7.92,7.35L8.37,6.06L8.88,7.33L10.24,7.36L9.19,8.23L9.59,9.54M19,13.5A5.5,5.5 0 0,1 13.5,19C12.28,19 11.15,18.6 10.24,17.93L17.93,10.24C18.6,11.15 19,12.28 19,13.5M14.6,20.08L17.37,18.93L17.13,22.28L14.6,20.08M18.93,17.38L20.08,14.61L22.28,17.15L18.93,17.38M20.08,12.42L18.94,9.64L22.28,9.88L20.08,12.42M9.63,18.93L12.4,20.08L9.87,22.27L9.63,18.93Z" />
    </svg>
  </button>


<div class="wrapper"><a class="site-title" rel="author" href="http://localhost:4000/">RSK Improvement Proposals</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link underline" href="http://localhost:4000/all">All</a><a class="page-link underline" href="http://localhost:4000/scalability">Scalability</a><a class="page-link underline" href="http://localhost:4000/security">Security</a><a class="page-link underline" href="http://localhost:4000/usability">Usability</a><a class="page-link underline" href="http://localhost:4000/fairness">Fairness</a><a class="page-link underline" href="http://localhost:4000/standardtrack">Standard Track</a></div>





      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Ephemeral Blockchain</h1>
  </header>

  <div class="post-content">
    <h1 id="ephemeral-blockchain">Ephemeral Blockchain</h1>

<table>
  <thead>
    <tr>
      <th style="text-align: left">RSKIP</th>
      <th style="text-align: left">215</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Title</strong></td>
      <td style="text-align: left">Ephemeral Blockchain</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Created</strong></td>
      <td style="text-align: left">3-FEB-2021</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Author</strong></td>
      <td style="text-align: left">SDL</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Purpose</strong></td>
      <td style="text-align: left">Sca</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Layer</strong></td>
      <td style="text-align: left">Core</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Complexity</strong></td>
      <td style="text-align: left">2</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Status</strong></td>
      <td style="text-align: left">Draft</td>
    </tr>
  </tbody>
</table>

<h1 id="abstract"><strong>Abstract</strong></h1>

<p>This RSKIP proposes that old blocks are removed from the blockchain. While removing blocks from the blockchain is a well known local resource optimization technique known as pruning, removing blocks from all nodes in consensus, as proposed here, is not.  This proposal competes with <a href="https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP213.md">RSKIP213</a> as implementing both techniques simultaneously does not seem to be provide much benefit.</p>

<h1 id="motivation"><strong>Motivation</strong></h1>

<p>The blockchain serves several purposes:</p>

<ol>
  <li>Wallets learn about an account balance</li>
  <li>Wallets list incoming transactions.</li>
  <li>Nodes reach consensus.</li>
  <li>Humans review all user’s transaction history.</li>
</ol>

<p>Learning about the account balance be partially achieved by state synchronization. While all transaction data is not available, the most important information, the user account balance, is part of the state.</p>

<p>Listing incoming transactions is generally only important when the user is waiting for payments, and need to distinguish between several incoming payments. Retrieving information of very old transactions is unimportant.</p>

<p>Reaching consensus can also be achieved if all nodes start synchronization from a certain old block checkpoint, for which the state is available.</p>

<p>Finally, reviewing all transaction history for all users may be useful to collect statistics, and also to increase the confidence on the immutability of the past, but it not a requirement for a blockchain to be useful.</p>

<p>Therefore, the conclusion is that there is no need that the consensus force stating synchronization from the genesis block. The protocol can achieve <strong>checkpoint consensus</strong>. Checkpoint consensus should not be confused with “weak subjectivity”, which refers to nodes making individual choices on synchronization checkpoints based on local information (peer reputation).  A <a href="https://arxiv.org/pdf/2101.05495.pdf">recent paper</a> presents the benefits of checkpoint consensus, but does not address the topic of node synchronization.</p>

<h2 id="checkpoint-consensus">Checkpoint Consensus</h2>

<p>Checkpoint consensus is realized by performing a state synchronization starting from a state checkpoint and applying transactions afterwards.  The benefit of checkpoint consensus is that in most blockchain use cases, transaction information is much larger than state information. In particular, the amount of state created by computation is much lower than the state created by direct data transfer from transaction calldata.</p>

<p>With checkpoint consensus, we reduce:</p>

<ul>
  <li>bandwidth consumed for old block propagation</li>
  <li>storage costs for storing old blocks</li>
  <li>SSD accesses required for reading the requested old blocks when queried by a peer, reducing the SSD capacity to manage the new block processing workload.</li>
</ul>

<p>Since bandwidth, storage and I/O accesses are priced in transaction costs, by reducing the consumption of these resources we are able to reduce the transaction cost, thus enabling use cases that were previously economically impractical.</p>

<h1 id="specification"><strong>Specification</strong></h1>

<p>We call an interval of M=1,000,000 blocks an epoch. This is approximately one year of blocks. An epoch i starts at block height C(i)=M*i.
Nodes store the world state at the current block N and at the checkpoint states at heights C(i) for all checkpoints i which have not been removed, and where C(i)&lt;=(N/M)*M, where “/” is the integer division. The state for checkpoint i is s(i). A checkpoint state must be available for peers to be queried after M confirmations. Peers will query the checkpointed state during the initial synchronization. The state s(i) can be created and stored while synchronizing or created at block C(i+1) by re-processing the blockchain from the previous checkpoint.</p>

<p>A chain segment is defined as a blockchain block interval starting from a checkpoint height C(i) and having exactly M blocks for any non-last segment, or in case of the last segment, having the maximum amount of blocks mined.</p>

<p>A checkpoint state is said to be <strong>removed by consensus</strong> if no node will require this state anymore to reach consensus. The state s(i) can be removed by consensus only a certain <strong>removal points</strong> in the processing of blocks. The removal points for checkpoint i are the blocks at heights C(j) for checkpoints j (j&gt;=i+2). The <strong>removal condition</strong> is the following: a state s(i) is removed by consensus if and only if the sum of cumulative work in the blockchain segments for checkpoints (i+1) to j (including the last unfinished segment) is greater than the blockchain segment for checkpoint i. Since a best chain can only be replaced by another chain with higher cumulative work, a consequence of the removal condition is that the removal of a checkpoint by consensus is irreversible.</p>

<p>A checkpoint state can be removed by consensus but not yet be removed from storage in nodes. The decision of when to remove a checkpoint state from storage is local to each node.</p>

<h2 id="synchronization">Synchronization</h2>

<p>The discovery of the best chain is similar to a non-checkpointed blockchain: the chain with more cumulative work wins. However, finding the checkpoint to start processing transactions requires a bit more work.</p>

<p>To find the starting checkpoint, we use formal specification of the removal condition. Let L be the last checkpoint in the blockchain (which may be incomplete due to unmined blocks). Let w(i) be the <strong>segment cumulative work</strong> in segment i for (0&lt;=i&lt;=L). Let t(i) be the <strong>tail cumulative work</strong>, defined as the sum of w(j) for all j such that (i&lt;=j&lt;=L).  Let the <strong>starting checkpoint</strong> be  j such that j=max( j=0..L-2: t(j)&gt;w(j+1)). The node will only request and execute the transactions for all blocks starting from the starting checkpoint.</p>

<p>This condition assures that a checkpoint will not change if blocks following it have decreased difficulty. The checkpoint will only advance if the tail cumulative difficulty is higher than the cumulative difficulty in segment cumulative difficulty.</p>

<p>Internally, the node starts by requesting all block headers from genesis to the last block informed by a peer, and then the node asks for the starting checkpoint block, then downloads the checkpointed state, then downloads all block transactions starting from the checkpoint, then processes all blocks starting in the checkpointed state.</p>

<h2 id="gas-costs">Gas costs</h2>

<p>The basic gas cost of a transaction is reduced from 21,000 to 16,000.
The gas per non-zero calldata byte is reduced from 68 to 16. Gas cost of zero bytes is unchanged.</p>

<h1 id="rationale">Rationale</h1>

<p>The idea of prunning old blocks (originally called “<a href="http://cryptonite.info/wiki/index.php?title=Main_Page">mini-blockchain</a>”) dates back to <a href="https://bitcointalk.org/index.php?topic=215936.0">2013</a>. In the mini-blockchain, removing old blocks was performed to maintain a <a href="https://web.archive.org/web/20150209130232/http://cryptonite.info/files/mbc-scheme-rev2.pdf">finite length</a> of unprunned blocks. Here we propose an algorithm to select when blocks should be discarded based on a security criteria. The criteria protects the blockchain against block reorganizations when a high proportion of honest hashrate turns dishonest or when hashrate is organically decreasing, keeping the lower bound to the time required to revert the blockchain. The mini-blockchain can only protect from such attack assuming a very rigid difficulty adjustment function, which slows down block creation if the hashrate is organically decreasing. A recent proposal called <a href="https://arxiv.org/pdf/2004.06911.pdf">CoinPrune</a> uses miners’ votes on the last valid snapshot to reaffirm snaptshot authenticity instead of the stronger strict consensus validation proposed here. 
An Ephemeral blockchain can help many of the state-of-the-art blockchain scaling solutions. Cheap calldata can provide the data availability required for 2nd layer rollups to support higher transaction volumes.</p>

<h2 id="gas-reductions">Gas Reductions</h2>

<p>Similar gas cost reductions than this proposal were implemented in Ethereum by <a href="https://eips.ethereum.org/EIPS/eip-2028">EIP2028</a>. EIP2028 argues that due the fast propagation of blocks, a reduction in calldata cost will not affect the consensus security. The same argument can be applied to RSK even with greater confidence, because RSK has a longer average block time. However, this RSKIP goes beyond that EIP argument and it actually reduces the full node resources required to process the blockchain to support the reduction in calldata cost.</p>

<h1 id="backwards-compatibility">Backwards Compatibility</h1>

<p>This change is a hard-fork and therefore all full nodes must be updated. SPV light-clients and Block explorers that are always in sync do not need to be updated.</p>

<h1 id="test-cases">Test Cases</h1>

<p>TBD</p>

<h2 id="security-considerations">Security Considerations</h2>

<p>We consider the security of an ephemeral blockchain historically by analyzing Bitcoin security over time, and as a comparison with the security assumptions of a drivechain.</p>

<h2 id="proof-of-work-equivalent-days">Proof-of-work Equivalent Days</h2>

<p>RSK currently has more than 50% of Bitcoin merge-mining hashrate. One year of cumulative work in RSK, while having the Armadillo monitoring for parallel forks, is enough to make re-mining impossible without community awareness. An attempt to steal by a 51% attack by Bitcoin miners will destroy the credibility of Bitcoin and backfire on the miners.</p>

<p>In the case of the Bitcoin blockchain, there is supporting historical evidence that one year of cumulative proof of work was enough to protect it from genesis to year 2020. During this period Bitcoin reached a 200B market capitalization, and the cumulative work required to rewrite the whole Bitcoin blockchain (based on the maximum hashrate at the time) was lower than the cumulative work of 365 days of blocks.  This data is shown in the graph “proof-of-work equivalent days” in http://bitcoin.sipa.be/. From year 2020 to February 2021 this measure has been increasing up to 600 days, but also the market capitalization reached 600B. Therefore we believe 1 year of block confirmations is enough for an ephemeral blockchain based on proof of work, but it’s possible to make the number of confirmations variable depending on the hashrate or the number of bitcoins in the peg.</p>

<h2 id="ephemeral-blockchain-vs-drivechain">Ephemeral Blockchain vs Drivechain</h2>

<p>The security model of full ephemeral blocks is similar, although not equal to, a drivechain. In a drivechain, the majority of the hashrate mining the sidechain can steal the pegged funds as long as they announce the malicious peg-out transaction in advance, and they confirm the malicious peg-out transaction openly for months using their hashrate. In an ephemeral blockchain, the majority of the sidechain hashrate can build a parallel chain fork starting from the last checkpoint but specifying an invalid malicious state in it. In this state, for example, all coins and tokens are owned by a malicious miner coalition. Afterwards if the malicious miner coalition wants to keep receiving Bitcoin block rewards, then it is forced to publicly expose their private fork by mining Bitcoin blocks with RSK Armadillo tags. These tags reveal the fork to the community. If malicious coalition has 51% of the hashrate, only after one year of mining the fork they can overtake the honest chain. One of the community plans for RSK is the transition of its 2-way peg to a drivechain when the drivechain is available in Bitcoin. If that happens, RSK will already be working under the security assumption of honest majority of the Bitcoin hashrate. The security assumptions for an ephemeral blockchain are similar to the ones of the drivechain. In one sense the risk in a ephemeral blockchain is higher, because the drivechain only puts the bitcoins at risk while the ephemeral blockchain also the tokens created in the RSK platform. However, in another sense the ephemeral blockchain reduces the risk, since RSK hashrate can reach the Bitcoin hashrate using the fork-aware merge-mining technique proposed by “External Confirmation Hashrate” (<a href="https://github.com/rsksmart/RSKIPs/blob/exthashrate/IPs/RSKIP178.md">RSKIP178</a>), “BTC-RSK timestamp linking” (<a href="https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP179.md">RSKIP179</a>) , and the yet unmerged “Timestamp-adjusted block difficulty transfer”, while the miners supporting a drivechain cannot automatically expand their security to 100% of the hashrate.</p>

<p>In case RSK transitions to a hybrid Powpeg-drivechain is used, a hashrate honest majority assumption is not needed, and an ephemeral blockchain implies a controlled reduction of the security of the RSK blockchain.</p>

<h1 id="copyright"><strong>Copyright</strong></h1>

<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>

  </div>

</article>

      </div>
    </main><footer>
    <div class="footer_cont">
        <div class="footer_box">
            <ul class="social-media-list"><li><a href="https://github.com/rsksmart/RSKIPs" target="_blank" rel="noopener"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Visit on Github</span></a></li></ul>
        </div>
    </div>
</footer><script src="../assets/js/dark_mode.js"></script>
    <script src="../../assets/js/dark_mode.js"></script>
  </body>

</html>
