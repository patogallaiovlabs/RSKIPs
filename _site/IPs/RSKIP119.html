<h1 id="precompiled-contract-for-inspecting-block-headers">Precompiled contract for inspecting block headers</h1>

<table>
  <thead>
    <tr>
      <th style="text-align: left">RSKIP</th>
      <th style="text-align: left">119</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Title</strong></td>
      <td style="text-align: left">Precompiled contract for inspecting block headers</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Created</strong></td>
      <td style="text-align: left">01-APR-19</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Author</strong></td>
      <td style="text-align: left">DM</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Purpose</strong></td>
      <td style="text-align: left">Usa</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Layer</strong></td>
      <td style="text-align: left">Core</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Complexity</strong></td>
      <td style="text-align: left">1</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Status</strong></td>
      <td style="text-align: left">Draft</td>
    </tr>
  </tbody>
</table>

<h2 id="abstract">Abstract</h2>

<p>A new precompiled contract (i.e., native, hardwired onto the RSK consensus layer) is introduced. This contract contains operations to allow inspection of several block header fields that can be useful for smart contract developers.</p>

<h2 id="motivation">Motivation</h2>

<p>Exploring the headers of specific blocks from solidity code (or assembly WOLOG) executing on the RVM could be too expensive. Doing this directly in solidity would require to write it and test it multiple times. Furthermore, different implementations can lead to errors potentially protruding to loss of funds. A well-written, tested and precompiled function set of operations to access the block header fields will tackle these problems while at the same time it will enforce certain level of security by implementing these as part of the RSK consensus.</p>

<h2 id="specification">Specification</h2>

<p>A new precompiled contract will be accessible at the <code class="highlighter-rouge">0x0000000000000000000000000000000001000010</code> address. It will implement the following functions (signatures and return values are as follows):</p>

<ul>
  <li><code class="highlighter-rouge">getBitcoinHeader(uint256 blockDepth) returns (bytes)</code></li>
  <li><code class="highlighter-rouge">getBlockHash(uint256 blockDepth) returns (bytes)</code></li>
  <li><code class="highlighter-rouge">getCoinbaseAddress(uint256 blockDepth) returns (bytes)</code></li>
  <li><code class="highlighter-rouge">getGasLimit(uint256 blockDepth) returns (bytes)</code></li>
  <li><code class="highlighter-rouge">getGasUsed(uint256 blockDepth) returns (bytes)</code></li>
  <li><code class="highlighter-rouge">getMergedMiningTags(uint256 blockDepth) returns (bytes)</code></li>
  <li><code class="highlighter-rouge">getMinGasPrice(uint256 blockDepth) returns (bytes)</code></li>
  <li><code class="highlighter-rouge">getRSKDifficulty(uint256 blockDepth) returns (bytes)</code></li>
  <li><code class="highlighter-rouge">getUncleCoinbaseAddress(uint256 blockDepth, uint256 uncleIndex) returns (bytes)</code></li>
</ul>

<p>There is a limitation on how deep the block to inspect can be from the executing block. It is possible to recover fields of the past 4000 blocks, meaning that the blockDepth must be a value between 0 and 3999 inclusive, where blockDepth 0 references the parent block of the executing block, blockDepth 1 references the grandparent of the executing block and so on. If there is no block at the specified depth, an empty byte array is returned.</p>

<h2 id="error-handling">Error handling</h2>

<p>In case of error, each of these methods behaves as if a solidity <code class="highlighter-rouge">assert</code> statement was being used. That is, contract state is reverted and all the gas is consumed.</p>

<h3 id="getbitcoinheader">getBitcoinHeader</h3>

<p>The method <code class="highlighter-rouge">getBitcoinHeader(uint256 blockDepth) returns (bytes)</code> takes as input the depth of the block to query block header fields from and returns a byte array representation of the associated Bitcoin merged mining header.</p>

<h4 id="validations">Validations</h4>

<ul>
  <li><code class="highlighter-rouge">blockDepth</code> must be an unsigned value ranging from 0 to 3999.</li>
</ul>

<h4 id="gas-cost">Gas cost</h4>

<p>This method has a fixed cost of 1,000 gas units. On top of that, normal transaction gas costs apply.</p>

<h4 id="sample-usage">Sample usage</h4>

<p>We want to recover the Bitcoin merged mining header for the parent block of the executing block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getBitcoinHeader(0)
</code></pre></div></div>

<p>We want to recover the Bitcoin merged mining header for the 2500th block starting at the executing block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getBitcoinHeader(2500)
</code></pre></div></div>

<p>We try to recover the Bitcoin merged mining header for a block beyond the 4000 depth limit. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getBitcoinHeader(5000) =&gt; []
</code></pre></div></div>

<p>We try to recover the Bitcoin merged mining header for a block that is not beyond the 4000 depth limit but still does not exist. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getBitcoinHeader(3500) =&gt; []
</code></pre></div></div>

<h3 id="getblockhash">getBlockHash</h3>

<p>The method <code class="highlighter-rouge">getBlockHash(uint256 blockDepth) returns (bytes)</code> takes as input the depth of the block to query block header fields from and returns a byte array representation of the block hash.</p>

<h4 id="validations-1">Validations</h4>

<ul>
  <li><code class="highlighter-rouge">blockDepth</code> must be an unsigned value ranging from 0 to 3999.</li>
</ul>

<h4 id="gas-cost-1">Gas cost</h4>

<p>This method has a fixed cost of 1,000 gas units. On top of that, normal transaction gas costs apply.</p>

<h4 id="sample-usage-1">Sample usage</h4>

<p>We want to recover the block hash for the parent block of the executing block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getBlockHash(0)
</code></pre></div></div>

<p>We want to recover the block hash for the 2500th block starting at the executing block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getBlockHash(2500)
</code></pre></div></div>

<p>We try to recover the block hash for a block beyond the 4000 depth limit. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getBlockHash(5000) =&gt; []
</code></pre></div></div>

<p>We try to recover the block hash for a block that is not beyond the 4000 depth limit but still does not exist. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getBlockHash(3500) =&gt; []
</code></pre></div></div>

<h3 id="getcoinbaseaddress">getCoinbaseAddress</h3>

<p>The method <code class="highlighter-rouge">getCoinbaseAddress(uint256 blockDepth) returns (bytes)</code> takes as input the depth of the block to query block header fields from and returns a byte array representation of the block’s coinbase address.</p>

<h4 id="validations-2">Validations</h4>

<ul>
  <li><code class="highlighter-rouge">blockDepth</code> must be an unsigned value ranging from 0 to 3999.</li>
</ul>

<h4 id="gas-cost-2">Gas cost</h4>

<p>This method has a fixed cost of 1,000 gas units. On top of that, normal transaction gas costs apply.</p>

<h4 id="sample-usage-2">Sample usage</h4>

<p>We want to recover the coinbase address for the parent block of the executing block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getCoinbaseAddress(0)
</code></pre></div></div>

<p>We want to recover the coinbase address for the 2500th block starting at the executing block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getCoinbaseAddress(2500)
</code></pre></div></div>

<p>We try to recover the coinbase address for a block beyond the 4000 depth limit. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getCoinbaseAddress(5000) =&gt; []
</code></pre></div></div>

<p>We try to recover the coinbase address for a block that is not beyond the 4000 depth limit but still does not exist. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getCoinbaseAddress(3500) =&gt; []
</code></pre></div></div>

<h3 id="getgaslimit">getGasLimit</h3>

<p>The method <code class="highlighter-rouge">getGasLimit(uint256 blockDepth) returns (bytes)</code> takes as input the depth of the block to query block header fields from and returns a byte array representation of the block’s gas limit.</p>

<h4 id="validations-3">Validations</h4>

<ul>
  <li><code class="highlighter-rouge">blockDepth</code> must be an unsigned value ranging from 0 to 3999.</li>
</ul>

<h4 id="gas-cost-3">Gas cost</h4>

<p>This method has a fixed cost of 1,000 gas units. On top of that, normal transaction gas costs apply.</p>

<h4 id="sample-usage-3">Sample usage</h4>

<p>We want to recover the gas limit for the parent block of the executing block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getGasLimit(0)
</code></pre></div></div>

<p>We want to recover the gas limit for the 2500th block starting at the executing block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getGasLimit(2500)
</code></pre></div></div>

<p>We try to recover the gas limit for a block beyond the 4000 depth limit. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getGasLimit(5000) =&gt; []
</code></pre></div></div>

<p>We try to recover the gas limit for a block that is not beyond the 4000 depth limit but still does not exist. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getGasLimit(3500) =&gt; []
</code></pre></div></div>

<h3 id="getgasused">getGasUsed</h3>

<p>The method <code class="highlighter-rouge">getGasUsed(uint256 blockDepth) returns (bytes)</code> takes as input the depth of the block to query block header fields from and returns a byte array representation of the block’s gas used.</p>

<h4 id="validations-4">Validations</h4>

<ul>
  <li><code class="highlighter-rouge">blockDepth</code> must be an unsigned value ranging from 0 to 3999.</li>
</ul>

<h4 id="gas-cost-4">Gas cost</h4>

<p>This method has a fixed cost of 1,000 gas units. On top of that, normal transaction gas costs apply.</p>

<h4 id="sample-usage-4">Sample usage</h4>

<p>We want to recover the gas used by the parent block of the executing block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getGasUsed(0)
</code></pre></div></div>

<p>We want to recover the gas used by the 2500th block starting at the executing block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getGasUsed(2500)
</code></pre></div></div>

<p>We try to recover the gas used by a block beyond the 4000 depth limit. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getGasUsed(5000) =&gt; []
</code></pre></div></div>

<p>We try to recover the gas used by a block that is not beyond the 4000 depth limit but still does not exist. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getGasUsed(3500) =&gt; []
</code></pre></div></div>

<h3 id="getmergedminingtags">getMergedMiningTags</h3>

<p>The method <code class="highlighter-rouge">getMergedMiningTags(uint256 blockDepth) returns (bytes)</code> takes as input the depth of the block to query block header fields from and returns a byte array representation of the block’s merged mining tags.</p>

<h4 id="validations-5">Validations</h4>

<ul>
  <li><code class="highlighter-rouge">blockDepth</code> must be an unsigned value ranging from 0 to 3999.</li>
</ul>

<h4 id="gas-cost-5">Gas cost</h4>

<p>This method has a fixed cost of 1,000 gas units. On top of that, normal transaction gas costs apply.</p>

<h4 id="sample-usage-5">Sample usage</h4>

<p>We want to recover the merged mining tags for the parent block of the executing block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getMergedMiningTags(0)
</code></pre></div></div>

<p>We want to recover the merged mining tags for the 2500th block starting at the executing block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getMergedMiningTags(2500)
</code></pre></div></div>

<p>We try to recover the merged mining tags for a block beyond the 4000 depth limit. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getMergedMiningTags(5000) =&gt; []
</code></pre></div></div>

<p>We try to recover the merged mining tags for a block that is not beyond the 4000 depth limit but still does not exist. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getMergedMiningTags(3500) =&gt; []
</code></pre></div></div>

<h3 id="getmingasprice">getMinGasPrice</h3>

<p>The method <code class="highlighter-rouge">getMinGasPrice(uint256 blockDepth) returns (bytes)</code> takes as input the depth of the block to query block header fields from and returns a byte array representation of the minimum gas price.</p>

<h4 id="validations-6">Validations</h4>

<ul>
  <li><code class="highlighter-rouge">blockDepth</code> must be an unsigned value ranging from 0 to 3999.</li>
</ul>

<h4 id="gas-cost-6">Gas cost</h4>

<p>This method has a fixed cost of 1,000 gas units. On top of that, normal transaction gas costs apply.</p>

<h4 id="sample-usage-6">Sample usage</h4>

<p>We want to recover the minimum gas price for the parent block of the executing block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getMinGasPrice(0)
</code></pre></div></div>

<p>We want to recover the minimum gas price for the 2500th block starting at the executing block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getMinGasPrice(2500)
</code></pre></div></div>

<p>We try to recover the minimum gas price for a block beyond the 4000 depth limit. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getMinGasPrice(5000) =&gt; []
</code></pre></div></div>

<p>We try to recover the minimum gas price for a block that is not beyond the 4000 depth limit but still does not exist. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getMinGasPrice(3500) =&gt; []
</code></pre></div></div>

<h3 id="getrskdifficulty">getRSKDifficulty</h3>

<p>The method <code class="highlighter-rouge">getRSKDifficulty(uint256 blockDepth) returns (bytes)</code> takes as input the depth of the block to query block header fields from and returns a byte array representation of the block’s RSK difficulty.</p>

<h4 id="validations-7">Validations</h4>

<ul>
  <li><code class="highlighter-rouge">blockDepth</code> must be an unsigned value ranging from 0 to 3999.</li>
</ul>

<h4 id="gas-cost-7">Gas cost</h4>

<p>This method has a fixed cost of 1,000 gas units. On top of that, normal transaction gas costs apply.</p>

<h4 id="sample-usage-7">Sample usage</h4>

<p>We want to recover the RSK’s difficulty for the parent block of the executing block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getRSKDifficulty(0)
</code></pre></div></div>

<p>We want to recover the RSK’s difficulty for the 2500th block starting at the executing block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getRSKDifficulty(2500)
</code></pre></div></div>

<p>We try to recover the RSK’s difficulty for a block beyond the 4000 depth limit. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getRSKDifficulty(5000) =&gt; []
</code></pre></div></div>

<p>We try to recover the RSK’s difficulty for a block that is not beyond the 4000 depth limit but still does not exist. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getRSKDifficulty(3500) =&gt; []
</code></pre></div></div>

<h3 id="getunclecoinbaseaddress">getUncleCoinbaseAddress</h3>

<p>The method <code class="highlighter-rouge">getUncleCoinbaseAddress(uint256 blockDepth, uint256 uncleIndex) returns (bytes)</code> takes as input the depth of the block to query block header fields from, the index of the uncle to query for and returns a byte array representation of the coinbase address for the indexed uncle.</p>

<h4 id="validations-8">Validations</h4>

<ul>
  <li><code class="highlighter-rouge">blockDepth</code> must be an unsigned value ranging from 0 to 3999.</li>
</ul>

<h4 id="gas-cost-8">Gas cost</h4>

<p>This method has a fixed cost of 1,000 gas units. On top of that, normal transaction gas costs apply.</p>

<h4 id="sample-usage-8">Sample usage</h4>

<p>We want to recover the coinbase address of the first uncle of the executing block’s parent block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getUncleCoinbaseAddress(0, 0)
</code></pre></div></div>

<p>We want to recover the coinbase address of the third uncle of the 2500th block starting at the executing block.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getUncleCoinbaseAddress(2500, 2)
</code></pre></div></div>

<p>We want to recover the coinbase address of the an unexistent uncle of the 2500th block starting at the executing block. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getUncleCoinbaseAddress(2500, 12) =&gt; []
</code></pre></div></div>

<p>We try to recover the coinbase address of an uncle for a block beyond the 4000 depth limit. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getUncleCoinbaseAddress(5000, 0) =&gt; []
</code></pre></div></div>

<p>We try to recover the coinbase address of an uncle for a block that is not beyond the 4000 depth limit but still does not exist. An empty byte array is returned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getUncleCoinbaseAddress(3500, 0) =&gt; []
</code></pre></div></div>

<h2 id="rationale">Rationale</h2>

<p>TODO (if any)</p>

<h2 id="references">References</h2>

<h3 id="copyright">Copyright</h3>

<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
