<h1 id="dynamic-contract-dependency">Dynamic Contract Dependency</h1>

<table>
  <thead>
    <tr>
      <th style="text-align: left">RSKIP</th>
      <th style="text-align: left">2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Title</strong></td>
      <td style="text-align: left">Dynamic Contract Dependency</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Created</strong></td>
      <td style="text-align: left">11-JUN-16</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Author</strong></td>
      <td style="text-align: left">SDL</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Purpose</strong></td>
      <td style="text-align: left">Sca</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Layer</strong></td>
      <td style="text-align: left">Core</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Complexity</strong></td>
      <td style="text-align: left">2</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Status</strong></td>
      <td style="text-align: left">Rejected</td>
    </tr>
  </tbody>
</table>

<h1 id="abstract"><strong>Abstract</strong></h1>

<p>This RSKIP describes new opcodes to enable contracts to declare and enable dependencies with other contracts. This will allow the partitioning of the transaction set into non-overlapping subsets to process them in parallel.</p>

<p>Rejected, in favour of <a href="https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP04.md">RSKIP04</a> .</p>

<h1 id="motivation"><strong>Motivation</strong></h1>

<p>RSK processes transactions from blocks one by one, in the specified order. This is because the effect of two random transactions can differ if applied in different orders. However most transactions do not use the same accounts/contracts and therefore their execution could be parallelized without interference.
There are several obstacles to parallelization. First, the dependencies are unknown until the transaction is actually executed. This implies that in case of an overlap in the set of modified accounts, transactions must be reverted and execution postponed. This optimistic execution can work on the average case, but can also be used as a vector to attack a node by DoS.
The transaction partitioning could be made deterministic if contract relations were to be defined prior execution. Two new opcodes are proposed in order to define and undefine such relations. The effect of change in a relation only applies in the next block. Therefore contracts can still communicate with any other contract providing those contracts register callback addresses before the callback addresses are actually called.</p>

<h1 id="specification"><strong>Specification</strong></h1>

<h3 id="add_call_relation">ADD_CALL_RELATION</h3>
<p>Arguments: &lt;address&gt;</p>

<p>Cost: TBD</p>

<p>Add a new relation to this contract.</p>

<h3 id="remove_call_relation">REMOVE_CALL_RELATION</h3>
<p>Arguments: &lt;address&gt;</p>

<p>Cost: TBD</p>

<p>Removes a relation from this contract.</p>

<h3 id="is_call_related">IS_CALL_RELATED</h3>
<p>Arguments: &lt;address&gt;</p>

<p>Cost: TBD</p>

<p>Returns True if there is a relation, or False otherwise.</p>

<h1 id="copyright">Copyright</h1>

<p>Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>.</p>
